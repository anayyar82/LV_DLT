-- SET spark.databricks.delta.schema.autoMerge.enabled = true;

-- -- ====================================================
-- -- 0️⃣ Quarantine Streaming Table
-- -- ====================================================
-- CREATE OR REFRESH STREAMING TABLE silver_events_patient_data_quarantine
-- AS
-- WITH cleaned AS (
--     SELECT *,
--            CASE WHEN D LIKE '"{%"}"' THEN
--              replace(
--                regexp_replace(regexp_replace(substring(D,2,length(D)-2),'""','"'),'\\\\\"','"'),
--                '\\u0000',''
--              )
--            ELSE replace(D,'\\u0000','')
--            END AS D_clean
--     FROM STREAM(patient_cdf)
-- ),
-- parsed AS (
--     SELECT *,
--            from_json(D_clean,'MAP<STRING,STRING>') AS D_map
--     FROM cleaned
-- ),
-- validated AS (
--     SELECT *,
--       CASE WHEN ID IS NULL THEN 'id_not_null'
--            WHEN BusinessID IS NULL THEN 'businessid_not_null'
--            WHEN D_map['created'] IS NULL THEN 'dcreated_not_null'
--            WHEN NOT (D_map['state'] RLIKE '^[A-Z]{2}$') THEN 'state_two_chars'
--            WHEN NOT (D_map['zipCode'] RLIKE '^[0-9]{5}(-[0-9]{4})?$') THEN 'zipcode_us_pattern'
--       END AS failed_constraint
--     FROM parsed
-- )
-- SELECT 
--   'silver_events_patient_data_cdc_scd2' AS flow_name,
--   'silver_events_patient_data_scd2' AS table_name,
--   failed_constraint AS constraint_name,
--   CASE failed_constraint
--     WHEN 'id_not_null' THEN 'ID IS NOT NULL'
--     WHEN 'businessid_not_null' THEN 'BusinessID IS NOT NULL'
--     WHEN 'dcreated_not_null' THEN 'D_created IS NOT NULL'
--     WHEN 'state_two_chars' THEN 'D_state RLIKE ^[A-Z]{2}$'
--     WHEN 'zipcode_us_pattern' THEN 'D_zipCode RLIKE ^[0-9]{5}(-[0-9]{4})?$'
--   END AS constraint_expression,
--   current_timestamp() AS violated_at,
--   named_struct(
--     'ID', ID,
--     'Shard', Shard,
--     'BusinessID', BusinessID,
--     'D_state', D_map['state'],
--     'D_zipCode', D_map['zipCode'],
--     'D_created', to_timestamp(D_map['created']),
--     'Created', Created,
--     'Updated', Updated,
--     'processedTime', current_timestamp()
--   ) AS record
-- FROM validated
-- WHERE failed_constraint IS NOT NULL;


-- CREATE OR REFRESH STREAMING TABLE silver_events_patient_data_scd2
-- (
--   ID STRING,
--   Shard STRING,
--   Private STRING,
--   Name STRING,
--   Address1 STRING,
--   Address2 STRING,
--   City STRING,
--   State STRING,
--   ZipCode STRING,
--   Country STRING,
--   PhoneNumber STRING,
--   BusinessID STRING,
--   Created STRING,
--   CreatedBy STRING,
--   Updated STRING,
--   UpdatedBy STRING,

--   D_id STRING,
--   D_name STRING,
--   D_address1 STRING,
--   D_address2 STRING,
--   D_city STRING,
--   D_state STRING,
--   D_zipCode STRING,
--   D_country STRING,
--   D_phoneNumber STRING,
--   D_businessId STRING,
--   D_private BOOLEAN,
--   D_created TIMESTAMP,
--   D_createdBy STRING,
--   D_updated TIMESTAMP,
--   D_updatedBy STRING,
--   D_extra MAP<STRING, STRING>,
--   D_records ARRAY<STRUCT<
--       record_id: STRING,
--       record_name: STRING,
--       option_checkBoxes: ARRAY<STRING>,
--       option_data: STRING,
--       option_fixedText: BOOLEAN,
--       priority: INT,
--       type: STRING,
--       record_extra: MAP<STRING, STRING>
--   >>,
--   P STRING,
--   V STRING,
--   processedTime TIMESTAMP
-- )
-- TBLPROPERTIES (
--   'delta.enableChangeDataFeed'='true',
--   'delta.enableRowTracking'='true',
--   'quality'='silver'
-- );



-- CREATE FLOW silver_events_patient_data_cdc_scd2 AS AUTO CDC INTO
--   silver_events_patient_data_scd2
-- FROM (
--   WITH cleaned AS (
--     SELECT *,
--            CASE WHEN D LIKE '"{%"}"' THEN
--              replace(
--                regexp_replace(regexp_replace(substring(D,2,length(D)-2),'""','"'),'\\\\\"','"'),
--                '\\u0000',''
--              )
--            ELSE replace(D,'\\u0000','')
--            END AS D_clean
--     FROM STREAM(patient_cdf)
--   ),
--   parsed AS (
--     SELECT *,
--            from_json(D_clean,'MAP<STRING,STRING>') AS D_map
--     FROM cleaned
--   ),
--   records_structured AS (
--     SELECT *,
--            CASE WHEN D_map['records'] IS NOT NULL THEN
--              transform(
--                from_json(D_map['records'],'ARRAY<MAP<STRING,STRING>>'),
--                r -> struct(
--                  r['id'] AS record_id,
--                  r['name'] AS record_name,
--                  CASE WHEN r['optionData.checkBoxes'] IS NOT NULL THEN
--                       from_json(r['optionData.checkBoxes'],'ARRAY<STRING>')
--                  ELSE array() END AS option_checkBoxes,
--                  r['optionData.data'] AS option_data,
--                  CAST(r['optionData.fixedText'] AS BOOLEAN) AS option_fixedText,
--                  CAST(r['priority'] AS INT) AS priority,
--                  r['type'] AS type,
--                  map_filter(r,(k,v)->k NOT IN ('id','name','optionData','priority','type')) AS record_extra
--                )
--              )
--            ELSE array() END AS D_records
--     FROM parsed
--   ),
--   validated AS (
--     SELECT *,
--       CASE WHEN ID IS NULL THEN 'id_not_null'
--            WHEN BusinessID IS NULL THEN 'businessid_not_null'
--            WHEN D_map['created'] IS NULL THEN 'dcreated_not_null'
--            WHEN NOT (D_map['state'] RLIKE '^[A-Z]{2}$') THEN 'state_two_chars'
--            WHEN NOT (D_map['zipCode'] RLIKE '^[0-9]{5}(-[0-9]{4})?$') THEN 'zipcode_us_pattern'
--       END AS failed_constraint
--     FROM records_structured
--   )
--   SELECT
--     ID, Shard, Private, Name, Address1, Address2, City, State, ZipCode, Country,
--     PhoneNumber, BusinessID, Created, CreatedBy, Updated, UpdatedBy,
--     D_map['id'] AS D_id,
--     D_map['name'] AS D_name,
--     D_map['address1'] AS D_address1,
--     D_map['address2'] AS D_address2,
--     D_map['city'] AS D_city,
--     D_map['state'] AS D_state,
--     D_map['zipCode'] AS D_zipCode,
--     D_map['country'] AS D_country,
--     D_map['phoneNumber'] AS D_phoneNumber,
--     D_map['businessId'] AS D_businessId,
--     CAST(D_map['private'] AS BOOLEAN) AS D_private,
--     to_timestamp(D_map['created']) AS D_created,
--     D_map['createdBy'] AS D_createdBy,
--     to_timestamp(D_map['updated']) AS D_updated,
--     D_map['updatedBy'] AS D_updatedBy,
--     map_filter(D_map,(k,v)->k NOT IN (
--       'id','name','address1','address2','city','state','zipCode','country',
--       'phoneNumber','businessId','private','created','createdBy','updated','updatedBy',
--       'records','P','V'
--     )) AS D_extra,
--     D_records,
--     P, V,
--     current_timestamp() AS processedTime,
--     _change_type, _commit_version, _commit_timestamp
--   FROM validated
--   WHERE failed_constraint IS NULL
-- )
-- KEYS (ID,BusinessID)
-- APPLY AS DELETE WHEN _change_type='delete'
-- SEQUENCE BY (_commit_version,_commit_timestamp)
-- COLUMNS * EXCEPT (_change_type,_commit_version,_commit_timestamp)
-- STORED AS SCD TYPE 2;
-- =======
-- -- SET spark.databricks.delta.schema.autoMerge.enabled = true;

-- -- -- ====================================================
-- -- -- 1️⃣ Silver SCD2 Table
-- -- -- ====================================================
-- -- CREATE OR REFRESH STREAMING TABLE silver_events_patient_data_scd2
-- -- (
-- --   ID STRING,
-- --   Shard STRING,
-- --   Private STRING,
-- --   Name STRING,
-- --   Address1 STRING,
-- --   Address2 STRING,
-- --   City STRING,
-- --   State STRING,
-- --   ZipCode STRING,
-- --   Country STRING,
-- --   PhoneNumber STRING,
-- --   BusinessID STRING,
-- --   Created STRING,
-- --   CreatedBy STRING,
-- --   Updated STRING,
-- --   UpdatedBy STRING,

-- --   D_id STRING,
-- --   D_name STRING,
-- --   D_address1 STRING,
-- --   D_address2 STRING,
-- --   D_city STRING,
-- --   D_state STRING,
-- --   D_zipCode STRING,
-- --   D_country STRING,
-- --   D_phoneNumber STRING,
-- --   D_businessId STRING,
-- --   D_private BOOLEAN,
-- --   D_created TIMESTAMP,
-- --   D_createdBy STRING,
-- --   D_updated TIMESTAMP,
-- --   D_updatedBy STRING,
-- --   D_extra MAP<STRING, STRING>,
-- --   D_records ARRAY<STRUCT<
-- --       record_id: STRING,
-- --       record_name: STRING,
-- --       option_checkBoxes: ARRAY<STRING>,
-- --       option_data: STRING,
-- --       option_fixedText: BOOLEAN,
-- --       priority: INT,
-- --       type: STRING,
-- --       record_extra: MAP<STRING, STRING>
-- --   >>,
-- --   P STRING,
-- --   V STRING,
-- --   processedTime TIMESTAMP
-- -- )
-- -- TBLPROPERTIES (
-- --   'delta.enableChangeDataFeed'='true',
-- --   'delta.enableRowTracking'='true',
-- --   'quality'='silver'
-- -- );

-- -- -- ====================================================
-- -- -- 2️⃣ Flow: Auto CDC into Silver SCD2
-- -- -- ====================================================
-- -- CREATE FLOW silver_events_patient_data_cdc_scd2 AS AUTO CDC INTO
-- --   silver_events_patient_data_scd2
-- -- FROM (
-- --   WITH cleaned AS (
-- --     SELECT *,
-- --            CASE WHEN D LIKE '"{%"}"' THEN
-- --              replace(
-- --                regexp_replace(
-- --                  regexp_replace(substring(D,2,length(D)-2),'""','"'),
-- --                  '\\\\\"','"'
-- --                ),
-- --                '\\u0000',''
-- --              )
-- --            ELSE replace(D,'\\u0000','')
-- --            END AS D_clean
-- --     FROM STREAM(patient_cdf)
-- --   ),
-- --   parsed AS (
-- --     SELECT *,
-- --            from_json(D_clean,'MAP<STRING,STRING>') AS D_map
-- --     FROM cleaned
-- --   ),
-- --   records_structured AS (
-- --     SELECT *,
-- --            CASE WHEN D_map['records'] IS NOT NULL THEN
-- --              transform(
-- --                from_json(D_map['records'],'ARRAY<MAP<STRING,STRING>>'),
-- --                r -> struct(
-- --                  r['id'] AS record_id,
-- --                  r['name'] AS record_name,
-- --                  CASE WHEN r['optionData.checkBoxes'] IS NOT NULL THEN
-- --                       from_json(r['optionData.checkBoxes'],'ARRAY<STRING>')
-- --                  ELSE array() END AS option_checkBoxes,
-- --                  r['optionData.data'] AS option_data,
-- --                  CAST(r['optionData.fixedText'] AS BOOLEAN) AS option_fixedText,
-- --                  CAST(r['priority'] AS INT) AS priority,
-- --                  r['type'] AS type,
-- --                  map_filter(r,(k,v)->k NOT IN ('id','name','optionData','priority','type')) AS record_extra
-- --                )
-- --              )
-- --            ELSE array() END AS D_records
-- --     FROM parsed
-- --   )
-- --   SELECT
-- --     ID, Shard, Private, Name, Address1, Address2, City, State, ZipCode, Country,
-- --     PhoneNumber, BusinessID, Created, CreatedBy, Updated, UpdatedBy,
-- --     D_map['id'] AS D_id,
-- --     D_map['name'] AS D_name,
-- --     D_map['address1'] AS D_address1,
-- --     D_map['address2'] AS D_address2,
-- --     D_map['city'] AS D_city,
-- --     D_map['state'] AS D_state,
-- --     D_map['zipCode'] AS D_zipCode,
-- --     D_map['country'] AS D_country,
-- --     D_map['phoneNumber'] AS D_phoneNumber,
-- --     D_map['businessId'] AS D_businessId,
-- --     CAST(D_map['private'] AS BOOLEAN) AS D_private,
-- --     to_timestamp(D_map['created']) AS D_created,
-- --     D_map['createdBy'] AS D_createdBy,
-- --     to_timestamp(D_map['updated']) AS D_updated,
-- --     D_map['updatedBy'] AS D_updatedBy,
-- --     map_filter(D_map,(k,v)->k NOT IN (
-- --       'id','name','address1','address2','city','state','zipCode','country',
-- --       'phoneNumber','businessId','private','created','createdBy','updated','updatedBy',
-- --       'records','P','V'
-- --     )) AS D_extra,
-- --     D_records,
-- --     P, V,
-- --     current_timestamp() AS processedTime,
-- --     _change_type, _commit_version, _commit_timestamp
-- --   FROM records_structured
-- -- )
-- -- KEYS (ID,BusinessID)
-- -- APPLY AS DELETE WHEN _change_type='delete'
-- -- SEQUENCE BY (_commit_version,_commit_timestamp)
-- -- COLUMNS * EXCEPT (_change_type,_commit_version,_commit_timestamp)
-- -- STORED AS SCD TYPE 1;





